---
title: "Задачи с Leetcode #2. Квадраты отсортированного массива"
date: 2022-01-22T11:55:42+03:00
tags: ["leetcode", "алгоритмы", "go", "сортировка"]
categories: ["leetcode", "алгоритмы"]
author: ["Pavel Kozlov"]
description: "Задачка на сортировку квадратов"
canonicalURL: "https://pavelkozlov.github.io/pavelkozlov/"
hideSummary: false
ShowReadingTime: true
ShowPostNavLinks: true
---

## Описание

Дан массив целых чисел, отсортированный по возрастанию. Необходимо вернуть массив из квадратов каждого числа, отсортированного по возрастанию.

## Примеры

| Исходные данные | Результат выполнения | Объяснение                                                                                         |
|-----------------|----------------------|----------------------------------------------------------------------------------------------------|
| -4,-1,0,3,10    | 0,1,9,16,100         | После возведения в квадрат, массив станет `16,1,0,9,100`. После сортировки получаем `0,1,9,16,100` |
| -7,-3,2,3,11    | 4,9,9,49,121         | После возведения в квадрат, массив станет `49,9,4,9,121`. После сортировки получаем `4,9,9,49,121` |

## Входные данные

- Длина массива от 1 до 104
- Элементы массива имеют значения от -104 до 104
- Элементы массива отсортированы по возрастанию

## Дополнительно

Возведение в квадрат каждого элемента и сортировка нового массива очень тривиальное решение. Попробуйте найти O(n)решение, используя другой подход

## Решение

```go

// функция помощник, возвращающая абсолютную величину числа
func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}

func sortedSquares(nums []int) []int {
	// Сразу аллоцируем массив, куда будут помещены результаты
	result := make([]int, len(nums))
	// Берем верхнюю и нижнюю границу,
	// которые на первой итерации являются первым и последним элементом
	left, right := 0, len(nums)-1
	// Итерируемся по массиву в обратно порядке
	for i := len(nums) - 1; i >= 0; i-- {
		// Берем большее значение из первого и последнего,
		// записываем его квадрат под индексом i (с конца) в результирующий массив
		// уменьшаем верхнюю/нижнюю границу в зависимости от результата сравнения
		if abs(nums[left]) < abs(nums[right]) {
			result[i] = nums[right] * nums[right]
			right--
		} else {
			result[i] = nums[left] * nums[left]
			left++
		}
	}
	// Возвращаем результирующий массив
	return result
}
```

## Пошаговое объяснение алгоритма

### Теория

Независимо от того, возводим ли мы в квадрат отрицательные значения или возводим в квадрат абсолютные значения, мы приходим к одному и тому же результату.

Возведение в квадрат абсолютных значений `[4, 1, 0, 3, 10]` дает нам массив `[16, 1, 0, 9, 100]`.

Возведение в квадрат отрицательных значений `[-4, -1, 0, 3, 10]` дает нам массив `[16, 1, 0, 9, 100]`.

Поскольку данный массив отсортирован по возрастанию, мы знаем, что наибольшее значение всегда будет либо абсолютное значением первого числа массива (абсолютное значение наименьшего отрицательного числа), либо абсолютное значение последнего числа данного массива.

Зная это, мы можем начать со сравнения абсолютных значений первого и последнего индексов данного массива, чтобы определить, какой из них больше. Таким образом мы найдем самое большое число в массиве. 

Затем мы можем добавить это число в конец нашего нового массива и сдвинуть верхнюю или нижнюю границу, что бы прежнее максимальное число больше не участвовало в сравнении.

Следующее самое большое значение будет вставлено в новый массив на предпоследнюю позицию. Таким образом новый массив будет так же отсортирован по возрастанию.

### Практика

Рассмотрим на примере массива `-4,-1,0,3,10`

Мы ожидаем увидеть `0,1,9,16,100`

- `result` равняется пустому массиву
- `left` = 0, `right` = 4
- при **первой** итерации сравниваем `4` и `10`. `10` больше, `right` становится 3. `result` становится `[100]`
- при **второй** итерации сравниваем `4` и `3`. `4` больше,  `left` становится 1, `result` становится `[16,100]`
- при **третьей** итерации сравниваем `-1` и `3`. `3` больше,  `right` становится 2, `result` становится `[9,16,100]`
- при **четвертой** итерации сравниваем `-1` и `0`. `-1` больше (из-за абсолютного значения),  `left` становится 2, `result` становится `[1,9,16,100]`
- при **пятой** итерации сравниваем `0` и `0` (`left` и `right` указывают на одно значение под индексом 2). `result` становится `[0,1,9,16,100]`
- итерация заканчивается, возвращаем результат

## Линейное решение

Задачу можно решить линейно - сначала создать массив с квадратами, затем отсортировать. Я использовал сортировку из стандартного пакета `sort`, вместо реализации `quicksort`. Алгоритмы сортировки будут рассмотрены позже в отдельном посте. Данный вариант работает, но имеет бОльшую сложность и выполняется медленнее на больших объемах данных.

```go
func sortedSquares(nums []int) []int {
	result := make([]int, len(nums))
	for i := range nums {
		result[i] = nums[i] * nums[i]
	}
	sort.Ints(result)
	return result
}
```