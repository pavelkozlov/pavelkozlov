---
title: "Задачи с Leetcode #1. Бинарный поиск"
date: 2022-01-22T11:55:42+03:00
tags: ["leetcode", "алгоритмы", "go", "поиск"]
categories: ["leetcode", "алгоритмы"]
author: ["Pavel Kozlov"]
description: "Несколько примеров бинарного поиска на Golang"
canonicalURL: "https://pavelkozlov.github.io/pavelkozlov/"
hideSummary: false
ShowReadingTime: true
ShowPostNavLinks: true
---

# Бинарный поиск

## Определение

> Двоичный (бинарный) поиск (также известен как метод деления пополам или дихотомия) — классический алгоритм поиска элемента в отсортированном массиве, использующий дробление массива на половины.

_Источник_ [Wikipedia](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA)

## Алгоритм

- Определение значения элемента в середине списка. Полученное значение сравнивается с ключом.
- Если ключ меньше значения середины, то поиск осуществляется в первой (левой) половине элементов, иначе — во второй (правой).
- Поиск сводится к тому, что вновь определяется значение серединного элемента в выбранной половине и сравнивается с ключом.
- Процесс продолжается до тех пор, пока не будет найден элемент со значением ключа или не станет пустым интервал для поиска.

## Пример

- Предположим, что у нас есть отсортированный список целых чисел: `1,2,5,7,8,11,13,17,19,40,55`
- Задача состоит в том, что бы найти число `17`
- Можно использовать линейный перебор: мы знаем что в списке 11 элементов, и по очереди обращаемся к каждому, сравнивая с искомым элементом. Является ли элемент с индексом 0 `17`? Нет. А с индексом 1? Нет. И т.д. В таком варианте решения, для массива из 11 элементов потребуется **11 сравнений**. А для массива из 1000 элементов - **1000 сравнений**. Поэтому такой алгоритм имеет сложность `O(n)`
- Алгоритм бинарного поиска: мы берем средний элемент из области поиска `[1,2,5,7,8,11,13,17,19,40,55]` - `11`. Делаем сравнение. Это число меньше `17`, значит область нашего поиска сужается до `[13,17,19,40,55]`. Мы фактически отбрасываем левую часть. Заново находим среднее число - `19`. Оно больше `17`. Поэтому отбрасываем правую часть. Теперь область поиска сужается до `[13,17]`. Находим среднее значение (в данном примере количество элементов четное, поэтому округляем в меньшую сторону) - `13`. Это значение меньше `17`. Поэтому отбрасываем левую часть. Область поиска сужается до `[17]`, т.е. мы нашли искомое значение. И при этом нам потребовалось **4 сравнения** (с `11`,`19`,`13`,`17`). Такой алгоритм имеет сложность O(log2(n))

## Сравнение

На маленьких объемах данных разница не так сильно видна. Попробуем большие данные

| Количество элементов | Бинарный поиск (количество сравнений) | Линейный поиск (количество сравнений) |
|----------------------|---------------------------------------|---------------------------------------|
| **2**                | 2                                     | 2                                     |
| **16**               | 5                                     | 16                                    |
| **1024**             | 11                                    | 1024                                  |
| **1 048 576**        | 21                                    | 1 048 576                             |

Мы видим что для 1 миллиона элементов, линейный поиск выполнит миллион сравнений, в то время как бинарный всего 21 сравнение

# Задача 1

## Описание

Дан массив целых чисел `nums`, отсортированных по возрастанию, и целое число `target`, необходимо написать функцию для поиска `target` в `nums`. Если `target` существует, надо вернуть его индекс. В противном случае вернуть `-1`. Вы должны написать алгоритм со сложностью `O(log n)`.

## Примеры

| Nums          | Target | Output | Описание                                                 |
|:--------------|:------:|:------:|:---------------------------------------------------------|
| -1,0,3,5,9,12 |   9    |   4    | `9` есть в `nums`, и индекс у него 4                     |
| -1,0,3,5,9,12 |   2    |   -1   | `2` отсутствует в `nums`, поэтому будет возвращено `-1`  |

## Входные данные

- Длина `nums` 1 - 104
- Элементы `nums` в диапазоне от -104 до 104
- Все числа в массиве уникальны и отсортированы по возрастанию

## Решение

```go
func search(nums []int, target int) int {
    // Устанавливаем границы поиска
	// На первом этапе это весь массив
	left := 0
	right := len(nums) - 1

	// До тех пор, пока поиск не сузится до 1 элемента, выполняем цикл
	for left <= right {
		// Находим средний элемент списка
		mid := (left + right) / 2
		// Если средний элемент равен искомому - возвращаем его индекс
		if nums[mid] == target {
			return mid
		}
		// Если средний элемент меньше искомого значения, сдвигаем левую границу
		// Следующий поиск будет на отрезке от среднего элемента до конца массива
		// Если средний элемент больше искомого, сдвигаем правую границу
		// Тогда следующий поиск будет от начала массива до середины
		if nums[mid] < target {
			left = mid + 1
		} else if nums[mid] > target {
			right = mid - 1
		}
	}
	// Если не найден искомый элемент при сужении области поиска до 1 элемента, вернется -1
	return -1
}
```

# Задача 2

## Описание

Вы менеджер продукта и в настоящее время возглавляете команду по разработке. К сожалению, последняя версия вашего продукта не прошла проверку качества. Поскольку каждая версия разрабатывается на основе предыдущей версии, все версии после первой плохой версии тоже плохие. 

Предположим, у вас есть `n` версий [1, 2, ..., n] и вы хотите найти плохую версию, из-за которой все последующие плохие. 

Вам предоставляется API `isBadVersion`, которое возвращает, является ли версия плохой. Реализуйте функцию для поиска первой плохой версии. Вы должны свести к минимуму количество обращений к API.

## Примеры

| Текущая версия | Первая плохая версия | Результат работы | Описание                                                                                                                                         |
|----------------|----------------------|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| 5              | 4                    | 4                | Вызов `isBadVersion(3)` вернул `false`, вызов `isBadVersion(5)` вернул `true`, вызов `isBadVersion(4)` вернул `true`. `4` - первая плохая версия |
| 1              | 1                    | 1                | Вызов `isBadVersion(1)` вернул `true`                                                                                                            |

## Входные данные

- Плохая версия всегда меньше или равна текущей
- Текущая версия находится в диапазоне от 1 до 230 включительно

## Решение

```go
func firstBadVersion(n int) int {
    // Устанавливаем границы поиска
    // На первом этапе это весь массив
	left := 0
	right := n - 1

    // До тех пор, пока поиск не сузится до 1 элемента, выполняем цикл
	for left <= right {
        // Находим средний элемент списка
		mid := left + (right-left)/2
		// Если средний элемент является плохой версией, сдвигаем правую границу
        // Следующий поиск будет от начала массива до середины 
		// Потому что нам нужна первая плохая версия
		// Если средний элемент не плохая версия - двигаем левую границу
        // Следующий поиск будет на отрезке от среднего элемента до конца массива
		// Потому что в левой части нет плохих версий
		if isBadVersion(mid) {
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	// Когда поиск сузился до 1 элемента, возвращаем левую границу, т.е. первую плохую версию
	return left
}
```

# Задача 3

## Описание

Дан отсортированный массив уникальных целых чисел и целевое значение. Необходимо вернуть индекс целевого значение, если оно найдено. Если нет, необходимо вернуть индекс, где целевое значение должно было бы находиться в данном массиве.

Алгоритм должен иметь алгоритмическую сложность `O(log n)`.

## Примеры

| Массив  | Целевое значение | Результат выполнения | Описание                                                               |
|---------|------------------|----------------------|------------------------------------------------------------------------|
| 1,3,5,6 | 5                | 2                    | `5` имеет индекс 2                                                     |
| 1,3,5,6 | 2                | 1                    | `2` нет в массиве, но правильный индекс для нее это 1, между `1` и `3` |
| 1,3,5,6 | 7                | 4                    | `7` нет в массиве, но правильный индекс для нее это 4, после `6`       |

## Входные данные

- Длинна массива с числами от 1 до 104
- Элементы массива находятся в диапазоне от -104 до 104
- Массив содержит уникальные целые числа, отсортированные по возрастанию
- Целевое значение находится в диапазоне от -104 до 104

## Решение

Комментировать данный код нет смысла, выполняется бинарный поиск из **примера 1**. **В примере 1** если не было успешного результата поиска, возвращалось значение `-1`.
В данном примере если найдено целевое значение - вернется его индекс. Если значение не найдено, вернется левая граница поиска (как в **примере 2**) - индекс под которым это значение находилось бы в массиве.

```go
func searchInsert(nums []int, target int) int {
	left := 0
	right := len(nums) - 1
	for left <= right {
		mid := (left + right) / 2
		if nums[mid] == target {
			return mid
		}
		if nums[mid] < target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return left
}
```

# Дополнительно

## Переполнение при left + right

В **примере 1** и **3** формула для получения среднего элемента: 
`mid := (left + right) / 2`. 

В **примере 2** формула немного другая: 
`mid := left + (right-left)/2`

Математически эти формулы равны и разницы между ними нет. Но есть некоторые ограничения в языках программирования. Например, в `Java`, `C++`, `C#` может получиться переполнение int если `left` + `right` будет больше 2147483647

## Рекурсивный метод

Ранее в примерах был рассмотрен итеративный подход в бинарном поиске. Функцию бинарного поиска можно так же реализовать рекурсивным подходом. Для **задачи 1** такой подход не подошел, потому что он не хранит индекс элемента. Новая функция вернет `0` если элемент есть в списке и `-1` если нет.

```go
func search(nums []int, target int) int {
	
	// Берем границы и средний элемент
    left, right := 0, len(nums)-1
	mid := left + (right-left)/2
	
	// Если средний элемент - искомый, вернем его индекс
	if nums[mid] == target {
		return mid
	}
	// Если средний элемент меньше искомого, отбрасываем левую часть. Если больше - правую
	if nums[mid] < target {
		left = mid + 1
	} else {
		right = mid - 1
	}

	// Если интервал поиска не сузился до 0, опять вызываем функцию search,
	// но передаем новый интервал поиска (уменьшенный вдвое)
	if left <= right {
		return search(nums[left:right+1], target)
	}

	// Возвращаем -1 если интервал поиска сузился до 0, и при этом ничего не нашли
	return -1
}
```